<script>
	// +버튼 누르면 시작
	let items = Array.prototype.slice.call(document.querySelectorAll("[id^='time-style']"), 0).map(function (obj) { return obj.textContent });
	console.log(items);

	// csrf용 쿠키
	function getCookie(name) {
		let cookieValue = null;
		if (document.cookie && document.cookie !== '') {
			const cookies = document.cookie.split(';');
			for (let i = 0; i < cookies.length; i++) {
				const cookie = cookies[i].trim();
				if (cookie.substring(0, name.length + 1) === (name + '=')) {
					cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
					break;
				}
			}
		}
		return cookieValue;
	}


	// "+"버튼 클릭시 이벤트
	let inputVals = [];
	function handleAddBtnClick(event) {
		let parentElement = event.target.parentNode;

		let addInput = document.createElement("input");
		addInput.setAttribute("type", "time");
		addInput.setAttribute("class", "addinput");

		let checkbt = document.createElement("button");
		checkbt.setAttribute("class", "checkbt"); 
		checkbt.textContent = "확인";

		parentElement.insertBefore(addInput, event.target.nextSibling);
		parentElement.insertBefore(checkbt, addInput.nextSibling);

		event.target.style.display = "none";
			
			checkbt.addEventListener('click', function(event){
				event.preventDefault(); 
				let val=addInput.value;

				if (inputVals.includes(val)) {
					alert("중복된 시간입니다. 다른 시간을 입력해주세요.");
					return;
				}
				
				inputVals.push(val); 

				// Add button의 데이터 속성에서 pk와 store_id 값 가져오기
				let pk = parentElement.dataset.pk;
    			let store_id = parentElement.dataset.storeId;

				console.log("pk값1:",pk);
				console.log("id값1:",store_id);
				console.log("찍어라",parentElement.dataset);


				fetch(`/manager/update/${pk}_${store_id}/`, {
					method: 'POST',
					body: JSON.stringify({ time: val }),
					headers: { 
						'Content-Type': 'application/json',
						'X-CSRFToken': getCookie('csrftoken') // CSRF 토큰 값 추가
					}
				})
				.then(response => response.json())
				.then(data => { console.log(data); /* 성공적으로 응답 받은 후 작업들... */ })
				.catch((error) => { /* console.error('Error:', error); 에러 발생 시 작업들... */ });


				getInputValue(parentElement,checkbt,addInput); 

				// "+" 버튼 추가
				let newAddBtn = document.createElement("button");
				newAddBtn.setAttribute("class", "addbtn");
				newAddBtn.setAttribute("type", "button");
				newAddBtn.textContent = "+";

				parentElement.appendChild(newAddBtn); // 클릭된 버튼의 부모 요소에 새로운 'addbtn' 추가
				// 수정 10.09
				// 클릭된 버튼의 다음 형제 요소인 'newAddBtn'으로 포커스 이동
				newAddBtn.focus();

				// 클릭된 버튼 제거
				checkbt.remove();
				
			});
		}


	document.addEventListener('click', function (event) {
		if (event.target.matches('.addbtn')) {
			handleAddBtnClick(event);

		}
	});


	// 추가 10.14 - 새로운 input값 받아온 버튼도 다시 클릭하면 값 변경 가능하게...
	// 버튼 클릭 이벤트 핸들러를 별도의 함수로 정의
	function handleButtonClick(event, attach, newButton) {
		event.preventDefault();
		let oldTimeInput = document.querySelector('.time-input');
		if (oldTimeInput)
			oldTimeInput.remove();
		let timeInput = document.createElement('input');
				timeInput.setAttribute('type', 'time');
				timeInput.classList.add('time-input');
				timeInput.addEventListener('change', function (e) {
					e.preventDefault();
					let buttons = Array.from(attach.querySelectorAll('button'));

					for (let button of buttons) {
						if (button.textContent === this.value) {
							alert("이미 존재하는 시간입니다.");
							this.style.display = '';
							return;
						}
					}
					newButton.textContent = this.value;
					buttons.push(newButton);
					buttons.sort((a, b) => {
						return a.textContent.localeCompare(b.textContent);
					});
					attach.innerHTML = '';
					for (let button of buttons) {
						attach.appendChild(button);
					}
					this.remove();
				});

				event.target.parentNode.insertBefore(timeInput, event.target.nextSibling);
	}
	console.log("inputVals1은: ", inputVals)

	// "추가하기" 버튼 클릭시 이벤트
	// 정렬작업중1
	// 기존 시간표랑 같이 정렬하기 위한 전역변수
	let allButtons = [];
	// 4번째
	document.addEventListener('click', function(event) {
		if (event.target.matches('.add_cookies')) {
			event.preventDefault();

			// #attach_btns 요소 찾기
			let attach = document.getElementById('attach_btns');
			// 위치 수정
			// let attach = address.parentNode;

			// inputVals 배열의 모든 값으로 새로운 버튼 생성
			inputVals.forEach(function(val) {
				let newButton = document.createElement("button");
				newButton.textContent = val;
				// attach.appendChild(newButton);

				// allButtons 배열에서 동일한 textContent를 가진 버튼이 있는지 확인
				if (!allButtons.some(button => button.textContent === newButton.textContent)) {
					attach.appendChild(newButton);
					allButtons.push(newButton);
				}


				// 전역변수에 추가
				// allButtons.push(newButton);
				// 버튼에 이벤트 리스너 추가
				newButton.addEventListener('click', function(event) {
					handleButtonClick(event, attach, newButton);
				});
			});
			console.log("전역변수 버튼들 ", allButtons);

			
			
			// 추가-10.14 추가하기누를때 정렬하기
			let buttons = Array.from(attach.querySelectorAll('button'));

			// finishBt 요소 제거하기 - 10.16
			let finishBtns = Array.from(document.querySelectorAll('#time-style'));
			finishBtns.forEach(btn => btn.remove());


			buttons.sort((a, b) => {
				return a.textContent.localeCompare(b.textContent);
			});
			attach.innerHTML = '';
			for (let button of buttons) {
				attach.appendChild(button);
			}
			// this.remove();


		}
	});
	console.log("inputVals2은: ", inputVals)




	// input값 가져오는 이벤트
	let inputValues = []; // 입력 값을 저장할 배열

	function getInputValue(parentElement, checkButtonElement,inputElement){
		let val=inputElement.value;
		
		let finishBt=document.createElement('button');
		finishBt.textContent=val; 
		finishBt.id='time-style'; 

		checkButtonElement.style.display='none';
		inputElement.style.display='none';

		items.push(val);
		
		items.sort(function(a,b){ 
			return new Date('1970/01/01 '+ a ) - new Date('1970/01/01 '+ b);
		});

		parentElement.appendChild(finishBt);

		let timeItems=Array.from(parentElement.querySelectorAll("[id^='time-style']"));

		// 화면상의 모든 버튼을 다시 불러와서 시간 순서대로 정렬
		timeItems.sort((a, b) => {
			return new Date(`1970/01/01 ${a.textContent}`) - new Date(`1970/01/01 ${b.textContent}`);
		});

		parentElement.innerHTML = ''; // 부모 요소의 모든 자식 요소를 제거

		for(let i=0; i<timeItems.length; i++){
			parentElement.appendChild(timeItems[i]); // 정렬된 버튼들을 다시 추가
		}

		finishBt.addEventListener('click', function(event){
			inputElement.value=val;
			inputElement.style.display='';
			checkButtonElement.style.display='';
			this.remove();
			
			let index = items.indexOf(this.textContent);
			
			if (index > -1) {
				items.splice(index, 1);
				inputValues.splice(inputValues.indexOf(val), 1); // 추가: inputValues 배열에도 값 제거
			}
			
			console.log(items);
		});
		
		console.log(items);
	}


	// function copyItems() {
	// 	let copiedItems = [];
	// 	for (let i = 0; i < items.length; i++) {
	// 		copiedItems.push(items[i]);
	// 	}
	// 	return copiedItems;
	// }

	function copyItems() {
		return Array.from(document.querySelectorAll("[id^='time-style']")).map(obj => obj.textContent);
	}


	

	// 기존시간값 가져와서 복사한후, 밑에 뿌리는 이벤트
	// 정렬작업중2
	function createButtonsFromItems() {

		let copiedItems = copyItems();

		copiedItems = copiedItems.concat(inputValues);
		// console.log("카피아이템 잘들어가나?", copiedItems)

		copiedItems.sort(function (a, b) {
			return a.localeCompare(b);
		});

		let address = document.getElementById('attach_btns');
		let attach = address.parentNode;

		for (let i = 0; i < copiedItems.length; i++) {
			let arrbtn = document.createElement("button");
			arrbtn.textContent = copiedItems[i];

			arrbtn.addEventListener('click', function (event) {
				event.preventDefault();
				let oldTimeInput = document.querySelector('.time-input');
				if (oldTimeInput)
					oldTimeInput.remove();
				let timeInput = document.createElement('input');
				timeInput.setAttribute('type', 'time');
				timeInput.classList.add('time-input');
				timeInput.addEventListener('change', function (e) {
					e.preventDefault();
					let buttons = Array.from(attach.querySelectorAll('button'));

					for (let button of buttons) {
						if (button.textContent === this.value) {
							alert("이미 존재하는 시간입니다.");
							this.style.display = '';
							return;
						}
					}
					arrbtn.textContent = this.value;
					buttons.push(arrbtn);
					buttons.sort((a, b) => {
						return a.textContent.localeCompare(b.textContent);
					});
					attach.innerHTML = '';
					for (let button of buttons) {
						attach.appendChild(button);
					}
					this.remove();
				});

				event.target.parentNode.insertBefore(timeInput, event.target.nextSibling);

			});

			// 전역변수에 추가
			allButtons.push(arrbtn);

			attach.appendChild(arrbtn);

		}
		console.log("복사한 배열값", copiedItems);
		// console.log("인풋값", inputValues);

	}
	createButtonsFromItems();



	// 버튼들 재정렬하기
	allButtons.sort((a, b) => a.textContent.localeCompare(b.textContent));
	let address = document.getElementById('attach_btns');
	address.innerHTML = '';
	for (let button of allButtons) {
		address.appendChild(button);
		// console.log("전역변수 버튼 값: ", button.textContent);
	}
	console.log("전역변수 버튼들 ", allButtons)



</script>